---
title: Garbage Collection
date: 2017-09-20 20:59:55
tags:
	- 垃圾回收
	- gc
	- garbage collection
	- tricolor 
	- 三色标记
	- 引用计数
	- 标记清除
categories:
    - 基础
---

对于高级语言，往往都带有一个机制来回收被遗弃不用的内存，称为‘垃圾回收’, 常见的回收机制包括 引用计数、分代收集、标记清除、三色标记。

<!--more-->

#### 引用计数法（reference counting）

针对每个对象，维护一个引用计数，当引用该对象的对象被销毁，被引用的对象引用计数减一，当被其他对象引用时，计数加一，当计数为零时，则回收对象

这个方法逻辑和实现简单，并且内存回收及时，对于内存比较紧张和实时性要求比较高的系统，应用比较广泛早期的java，php，python都采用了这种办法。

这个办法的缺点是，频繁更新引用影响性能以及循环引用的问题。


#### 分代收集

在面向兑现的语言中，绝大多数对象生命周期非常短，分代的思想是将堆氛围两个或多个代的空间，新创建的放到新生代，随着垃圾回收的重复执行，生命周期长的放到老年代中。新生代的回收速度快于老年代。

#### 标记清除法 （mark and sweep)

该方法分为两步，

    1. 标记：从根变量开始采用深度优先的办法迭代找出所有被引用的对象，标记为‘被引用’
    2. 清除：清除Heap中所有未标记的对象

这个办法优点是根据引用关系找到所有需要保留的对象，避免了循环引用的问题。缺点是，在标记阶段需要停掉程序的运行(Stop the World)避免在gc过程中引用关系的变化, 另一个缺点是经过多轮处理后会流线很多小的离散的内存区

#### 三色标记法 （Tricolor marking)

这个办法只是一个概念，在实现过程中并不是把对象标成三个颜色。标记的过程是并发的，不必STW。标记的过程逻辑如下，初始所有对象都是白色的。

	1. 将所有根变量引用的对象标记为灰色。根变量包括 全局变量，函数的局部变量、参数
	2. 将灰色区域的变量引用的白色对象也标记为灰色，然后将引用的灰色对象标记为黑色
	3. 循环反复直到灰色区域没有对象

这个标记过程可以和程序并行运行，即便在标记线程停顿情况下，如果有引用的变化或者新对象被引用，只要保证黑色对象没有对白色对象的引用就能保证最终能遍历到所有需要保留的对象。为了保证这个特性，需要在程序编译环节实现 write-barrie，当出现对象被引用的操作时，将其标记为灰色。为什么不将新的引用直接标黑呢？因为如果标黑就不能保证将被引用的新的对象所引用的对象被标记，因为标记只会在灰色区域里拿下一个要标记的对象。

实现过程通常是一个栈保存所有要mark的对象，对应概念的灰色区域，mark后对象就进入到黑色区域，轮循不到的则遗留在白色区域，write barrie是向栈中增加一条要mark的对象。

#### Golang的垃圾回收演进

1.5之前使用mark and sweep，有明显的STW，这需要程序员手动的对程序进行优化，比如减少对象的使用。

1.5 后使用tricolor的办法并发的， 但也会出现短时间的STW，在1.7后又进行了一次优化减少了STW点， 最后优化的1.9时候STW就不是一个困扰golang程序员的问题了。

但为了减少垃圾回收过程中的压力，还是尽可能的减少小对象的引用。


参考资料：

http://newhtml.net/v8-garbage-collection/

https://en.wikipedia.org/wiki/Tracing_garbage_collection

https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md