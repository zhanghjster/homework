---
layout: post
title: IO 系列1
date: 2018-09-23 13:39:44
tags:
  - Page Cache
  - Buffers
  - Standard IO
  - Direct IO
---

```
本文翻译于 https://medium.com/databasss/on-disk-io-part-1-flavours-of-io-8e1ace1de017
```

了解IO的工作原理、使用场景、底层存储系统、及算法取舍对于开发和运维人员的日常工作都有很大帮助，能使他们在数据库选型、问题定位、性能调优等方面会做出更佳的选择

相比于经常被讨论的网络IO，文件系统IO则不是那么引人注意。部分原因是网络IO具有更多的更能和细节，从一个操作系统到另一个操作系统各不相同，而文件系统IO的工具集则小的很多。此外，现在系统中人们大多数使用数据库作为存储手段，程序通过网络上的驱动程序与其通信，文件系统则留给数据库开发人员理解和处理。理解数据如何从磁盘中读取仍然很重要。

IO有多种概念：

系统调用：open，write，read ，fsync，sync，close

标准IO：fopen，fwrite，fread，fflush，fclose

向量IO：writev，readv

内存映射IO：open，mmap，msync，munmap

我们先来讨论标准IO以及用户态优化，因为程序开发人员最终使用的最多

#### Buffered IO

在谈论stdio.h函数时，在“缓冲”方面存在一些混淆。使用标准IO时，可以选择完全缓冲和行缓冲，也可以选择不用任何缓冲。这种“用户空间”缓冲与内核缓冲（页面缓存）无关，在本文后面将讨论。“缓冲”和“缓存”可以区分开来，这可能会明确区分这些概念

#### Sector/Block/Page

块设备(Block device)是一种特殊的文件类型，它提供对硬件设备(HDD, SSD)的缓冲访问(Buffered Access)。块设备工作于扇区(Sector)上，每个扇区由相邻字节组成，通常为512字节。块设备的最小传输单元是扇区，它不可能传输小于扇区大小的数据，更多情况下则是一次传输多个连续扇区。文件系统(File System)最小的可寻址单元是块(Block)，它由多个连续的扇区组成，典型的块大小是512、1024、2048、4096字节。通常，IO是通过虚拟内存(Virtual Memoty)完成，虚拟内存将请求的文件系统块缓存在内存并作为中间操作的缓冲区。虚拟内存与页面(Page)一起使用，这些页面被映射到文件系统的块，典型的页面大小是4096字节。

总的来说就是：虚拟内存页面映射到文件系统块，文件系统块映射到块设备的扇区

### Standard IO

标准IO(Standard IO)使用系统调用$read()$ 和$write()$执行IO操作。当读取数据时，会首先寻址页缓存(Page Cache)，如果数据不存在，则会触发页面错误(Page Fault)来从块设备读取内容，这意味着对为映射区域执行读取操作会华为更长时间。

当执行写入操作，内容会首先写入到页面缓存(Page Cache)，这意味着数据不是立即到达硬件设备。当内核决定‘脏数据回写’(writeback of dirty page)时才会被写入到硬件设备

<img src="http://owo5nif4b.bkt.clouddn.com/1%2ABIhWPv9P-ePgQX5Ien1AQA.png" width="400">

标准IO采用用户空间缓冲区(Byte Buffer)，然后将内容复制到页面缓存。使用O_DIRECT标志时缓冲区则直接写入块设备。

#### Page Cache

页面缓存(Page Cache)存储最近被访问的文件片段(fragment)，这些片段在最近的时间内更有可能被访问。当使用要使用磁盘文件时，$read()$和$write()$调用不会直接访问磁盘，而是通过页面缓存。

<img src="http://owo5nif4b.bkt.clouddn.com/1%2Ayl8Rdk17NtAtpYndh3XFQw.png" width="400">

在执行$read$操作时，页面缓存会被首先查询，如果数据已经在页面缓存中，它则被直接复制给用户，不会有磁盘访问，完全是内存操作。否则，文件内容需要先从存储介质中读取并加载到页面缓存中，然后返回给用户。如果页面缓存已满，最少使用的页面会被刷写到磁盘并从从页面缓存中清除为新页面留出空间

$write$调用只是将用户控件的缓冲区复制到内核的页面缓存并将写入的页面标记为‘dirty’。稍后，内核在称为‘刷新’(flush)或'回写'(writeback)进程中将修改写入到磁盘上。实际IO通常不会立即发生，页面缓存里的数据会同时被$read$调用读取。

被标志位‘dirty’的页面缓存会被刷写到磁盘上，因为它们已经和磁盘上的内容不同。这个过程称为'回写'(writeback)。回写存在潜在的缺点，比如IO请求排队，所以了解用于回写的阈值和比率以及查看队列深度对于避免限制和高延迟有很大帮助，可以在Linux文档中找到有关调整虚拟内存的更多信息。

页面缓存的背后逻辑由'时间局部性'(Temporal Locality)原理解释，该原理表明最近访问的页面将在最近的某个时间点再次被访问。

另一个'空间局部性'(Spatial Locality)原理则表明一个数据被使用后，在空间上更接近的数据在最近也会被访问。这被用于被称为'预取'过程，该过程提前加载文件内容用于预期的访问，进而分摊一部分IO成本

页面缓存还通过延迟写入和合并相邻读取来提高IO性能

缓冲区缓存(Buffer Cache)和页面缓存(Page Cache)以前是完全独立的概念，在Linux内核2.4后统一。现在它主要被称为页面缓存，但有些人仍然使用数据缓冲区缓存，实际上它们是同一个意思。

页面缓存保存最近被访问或将要访问的文件内容，因此所有的都通过它的IO操作可以为$read-write-read$的操作序列可以完全在内存上进行而不必有任何的磁盘操作。

#### Delaying Errors

当执行$write$操作时，确保数据真正的到达磁盘是很重要的，因为它很可能被写入到缓存中，而在后续的刷写过程中有可能报错。[这里](https://lwn.net/Articles/457667/)有更多的内容可以供参考

### Direct IO

有些时候使用内核页面缓存来执行IO时不可取的，在打开文件时候使用O_DIRECT标志则指示操作系统绕过页面缓存直接对块设备直接进行IO操作。这意味着写数据时数据会直接刷写到磁盘上而不是先写到缓存页面再由内核回写。

对于使用'Direct IO'的程序很可能导致性能下降，但可以更细粒度的控制IO操作并提高性能。通常，使用这种类型IO的程序会在应用程序里实现缓存层。

<img src="http://owo5nif4b.bkt.clouddn.com/1%2AZj8_whEZm_AEaBXBtqdiBw.png" width="400">



Direct IO在$PostgreSQL$和$MySQL$中被使用，开发人员更细粒度的控制数据访问操作，可能使用自定义的IO调度程序和缓存。例如，$PostgreSQL$在WAL中使用Direct IO来确保尽快的写入来保证持久性，因为他们确信数据不会被立即使用，因此绕过页面缓存写入不会导致性能下降。

不鼓励同时使用Direct IO和页面缓存打开相同的文件，因为即使数据位于页面缓存中，也会对磁盘设备执行直接操作，这可能会导致不希望的结果。

#### Block Alignment

由于'Direct IO'是绕过缓存也直接操作底层存储，它要求所有操作都是与扇区边界对齐的。也就是每个操作的开始地址必须是扇区大小(通常为512)的倍数，并且缓存的大小也应该为扇区的倍数。当使用页面缓存时，因为写操作先是在没存上执行，对齐显得不是那么重要：当真正的写入操作执行时，内核会确保分割页面并且按照扇区对齐将数据写入磁盘

<img src="http://owo5nif4b.bkt.clouddn.com/1%2A7MM3iNFLcQnUc9wZ8aISRw.png" width="400" title="不对齐">

​										不对齐

<img src="http://owo5nif4b.bkt.clouddn.com/1%2AZiSuwydbAZpuqcUW4puaHw-2.png" width="400">

​										   对齐

不管是否使用O_DIRECT标识，写入数据时快对齐的读写都是好的想法，因为跨段边界会导致更多扇区需要加载和写入。

### Summary

IO不管是是否使用缓存，了解原理对实际操作中避免误用起到很大的作用。