---
title: Signed Integer
date: 2017-10-04 09:26:07
tags:
    - 基础
    - 补码
    - 反码
    - 源码
    - one's complement
    - two's complement
    - signed magnitued
categories:
    - 基础
---

对于我们人类来说，认知正数或者负数是没有任何麻烦的，因为是我们发明了它，在一个数的前面有"-"号就表示负数，前面有"+"或者不加符号就表示正数，很简单不是吗? 但，这对于人类的另一个发明计算机来说，就不那么容易了，应为它们的大脑里只有"0"和"1"，没有加号和减号的概念。辣莫，怎么才能让它们能够识别正负数呢？

自从计算机被发明以来，世界上的各种研究员、数学家、计算机科学都在殚精竭虑的寻找在二进制编码所限制的世界里表示负数。经过多年的求索与争吵产生了三种编码方法，下面我们详细看一下每一种方法，感受一下他们的原理和使用场景

<!-- more -->
#### 原码(Signed Magnitude Representation)

对于普通的无符号整数，用"0"和"1"组成的字符串表示。一个字节(8bit)可以表示范围是 $00000000$ — $1111 1111$，十进制值为 0 — 255

而对于有符号的整数，鉴于一个数字的"正负"只是一个二进制状态，源码的发明者使用二进制里一个bit位来标示符号(通常是最高位)。符号位为1表示负数，0为正数，其余位用来表示数的大小

比如用八位的二进制源码来标示$+1$ 和 $-1$分别为:

$$[+1]_{10} = [1000\ 0001]_2\\ [-1]_{10}=[1000\ 0001]_2$$ 

一个字节(8bit)表示的有符号整数范围：$11111111$ — $011111111$, 十进制为 -127 — +127

这种编码的优点就是简单，简单到你在说它"简单"时需要说明一下并没有贬低发明者的意思。它更适合人类阅读，这在计算机应用早期人们需要经常查看内存数据的年代是非常有用的，但后来逐步被后浪拍在沙滩上，在浮点数的表示方法里还留有它的一席之地

说完优点，下面是他的缺点

首先，0有两种编码方式$10000000$ 和 $000000000$ ，也就是$+0$和$-0$，这在判断一个数是否为0时需要考虑两种情况，增加了电路的设计复杂度

其次，它不能直接使用计算无符号整数的计算单元去进行计算，比如，要计算8-bit的有符号整数 $-1+(-1)$ ， 使用无符号整数计算硬件												$$\\1000\ 0001 + 1000\ 0001 = 1\ 0000\  0010$$

最高位的 1 因为超过了8bit溢出而被忽略，最终结果是 $[0000\ 0010]_{2}$ = $[2]_{10}$ ，显然结果不是我们想要的，一个容易想到的办法是计算时保留符号位

$$\\1000\ 0001 + 1000\ 0001 = [1000\ 0010 ]_2 = [-2]_{10}$$

Bingo，得到我们的结果。但这就对了吗？如果 $1+(-1)$ 怎么办呢？

$$\\0000\ 0001 + 1000\ 0001 = ?000 0010$$

保留哪个符号位呢？值的部分是$0010$ = $[2]_{10}$ 也显然不对。辣莫，问题到底出在哪里？

问题在于，这种编码方式无法表达一个整数和它的相反数之间的数学关系。即，一个整数和它的相反数相加的结果是应该0。从上计算看到 $[+1]_2$($[0000\ 0001]_2$ 加上它的相反数$[-1]_2$($[1000\ 0001]_2$) 的结果怎么处理符号位，最终结果都不会是0

其实，要设计逻辑电路解决它的问题也不是不可能，但这要增加更多算法和逻辑电路，增加硬件的复杂度和成本，而另外两种算法里则不存在这个问题

#### 反码(one's complement)

反码的表示方法依然是使用一个bit位(通常最高位)来表示符号，0表示正数，1表示负数。

如果是正数，除符号位之外的所有位表示它的绝对值

$$\\ [+1]_{反码} = [0000\ 0001]_2$$

如果是负数，将它正数的反码表示逐位取反

$$\\ [-1]_{反码} = [1111\ 1110]_2$$	

 $n$ 位二进制能表示整数的范围是， $-(2^{n-1}-1)<= x < -2^{n-1} - 1$ 

从定义可知，反码解决了原码的整数与相反数相加为不为0的问题，因为根据定义，一个整数的与他的相反数相加的结果是$[1111\ 1111]_2$ = $[-0]_{10}$

不过，反码依然没有解决 $+0$ 和 $-0$ 的问题，并产生了一些新的问题，比如溢出(二进制数进行数学运算时，结果超出了可用位表示的范围)。举个栗子，计算8bit的 $[127]_{10}+[1]_{10}$ 

$$\\ [0111\ 1111]_2 + [0000\ 0001]_2 =[1000\ 0000]_2$$  

根据定义，最高位因为是1，所以结果为负数，这显然是错误的结果。当两个正数相加，但结果超出他能表示范围时，总是会出现这种情况

如果两个负数相加情况更复杂，除表示的值会溢出外，符号位也会溢出，比如 $-1 + (-1)

$$\\ [1111\ 1110]_2 + [1111\ 1110]_2 = [1\ 1111\ 1100]_2$$

最高位符号位溢出到了bit9被忽略，因为值的部分也出现了溢出，最总结果的第8bit依然为1，保持了符号，但这种也不全能保证， 比如  $(-126) + (-125)$ 

$$\\  [1000\ 0001]_2 + [1000\ 0010]_2= [1\ 0000\ 0011]_2$$

最高符号位溢出到bit9被忽略，而值的部分没有出现溢出，所以导致最终结果符号位为0的正数，显然错误。

辣莫，该如何解决这个问题呢？方法就是"端回进位"(End Arround Carry)，逻辑就是，将溢出位加到最终结果的最后一位，如有进位继续进位之后则为最终结果

再以 $(-1) + (-1)$ 为例, 将计算结果 $[1\ 1111\ 1100]_2$	溢出到第九位的1加到最右，结果为 $[1111\ 1101]_2 = [-2]_{10}$ ，是正确的结果

可见，用反码表示的有符号整数要直接用于计算，计算硬件还需要做出特别的设计来解决他存在的问题，下面介绍一个最简单的，对于硬件来说复杂度更低的编码 ‘**补码**’			

#### 补码

在补码之前先熟悉一些其他的概念

##### 基数(Radix)

在数学里，基数是指在"定位数系"(positional numeral system) 里用于表示"数"(number)的包括0在内的"数字"(digit)的个数，比如，在十进制系统里，基数是10，用于表示数的数字为0至9的10个数字，在二进制系统里，基数是2，用于表示数的数字是0和1

在"定位数系"里，一个"数"通常写作$[x]_y$ ，$x$ 是由‘数字’组成的字符串，$y$是他的基数。比如$[11]_{10}$表示十进制的11，而$[11]_2$ 是二进制的11(十进制的3)。十进制因为是我们人类最常使用的进制，所以很多情况下下标$y$会被忽略使用

对于一个基数为$b(b>1)$的数字系统，形如$d_1d_2...d_n$的字符串表示的'数'为	

$$\\ d_1b^{n-1} + d_2b^{n-2} + … + d_nb^0, (0<=d_j<b)$$				

##### 基数补(Radix Complements)

一个基数为 $b$ 的 $n$ 位数 $y$ 的‘基数补‘定义为

$$\\ b^n-y$$

以两位的十进制数 $y$ 为例，$b$ = 10  $n=2$ ，基数补为

$$\\ 10^2 - y = 100 - y$$							

可见，$n$ 位数 $y$ 的基数补就是与 $y$ 相加之后和会从 $n$ 位进位为$n+1$位的那个数

十进制里"基数补"也叫"10补数"，二进制里"基数补"称作"二补数"，也叫**补码**

##### 减量基数补(Diminished Radix Complement)

一个基数为 $b$ 的 $n$ 位数 $y$ 的"减量基数补"定义为

$$\\ (b^n -1 ) - y$$

显然，对于 $y$ 

$$\\ 减量基数补  =  基数补 - 1$$						  

可见， $y$ 的 "减量基数补"  加上$y$后的和是以 $b$ 为基数的 $n$ 位数所表示的最大的数， 在十进制里，减量基数补也叫"9补数"，二进制里则叫"1补数",也叫**反码**

那么，为什么要有减量基数补呢？因为它比基数补更容易计算，并且它加上1后就是基数补：

$$\\ \begin{split}y的基数补\\ &= b^n - y \\&= b^n - 1 + 1 - y \\&= ((b^n-1) - y) + 1 \\&= y的减量基数补 + 1\end{split}$$

计算减量基数补有多简单呢？将你的数字的每一位减去 $(b-1)$ 就是了，比如求 $[48323]_{10}$ 的"减量基数补",只需要将每一位减去 $9$ 即可，结果是 $[51676]_{10}$ ，将其加上 $1$ 就是‘基数补’了，$[51767]_{10}$

我们再看一下二进制下的"减量基数补"，计算方法就是用 $1$ 去减每一位的值，比如 $[1010]_2$每一位减一后结果为$[0101]_2$。二进制下 $1-0=1$  $1-1=0$ 结果相当于将值取反，所以计算‘减量基数补’也就相当于将每一位取反。这也就是为什么它也叫 **反码** 的原因

下面从数学角度证明一下为什么将‘数’的每一位的‘数字’用 $b-1$ 减去后得到的数是  **减量基数补 **

因为

$$\\ b^n - 1= b^n - 1^n$$

由定理：

$$\\ x^{n+1} - y^{n+1} = (x-y)\sum^n_{k=0}x^ky^{n-k}$$				

得到：

$$\\ b^n - 1^n = (b-1)\sum^{n-1}_{k=0}b^k1^{n-k}=(b-1)\sum_{k=0}^{n-1}b^k$$

展开后结果是：

$$\\ \begin{split}b^n - 1 \\ &= (b-1)(b^0+b^1+…+b^{n-1}) \\&= (b-1)b^{n-1} + (b-1)b^{n-2} + … + (b-1)\end{split}$$

又因为基数为 $b$ 的 $n$ 位数 $y$ ，字符串表示如果是'$d_1d_2…d_n$'，它的值为

$$\\ d_1b^{n-1} + d_2b^{n-2} + … + d_nb^0, (0<=d_j)$$

所以 

$$\\ \begin{split}b^n - 1 - y =((b-1) - d_1)b^{n-1} + ((b-1) - d_2)b^{n-2} + … + ((b-1) - d_n)\end{split}$$

所以如果最终结果的字符串表示如果是 ‘$e_1e_2…e_n$’ ， 那么

$$\\ e_1 = (b-1) - d_1,  e_2 = (b-1) - d_2, …, e_n=(b-1) - d_n$$

也就是前面所说的，通过 $b-1$ 减去每一位得到的数就是 ‘减量基数补’

##### 补数法

假设我们有两个 $n$ 位的正整数 $x $ 和 $y$，基数为  $b$ , 则如果要计算 $x - y$ ，采用补数法计算过程如下：

1. 计算 $y$ 的基数补, 通过先计算 $y$ 的减量基数补然后加1的办法, 设其结果是 $z$
2. 计算 $x$ 与 $y$ 基数补的之和, 计算 $x + z$
3. 去掉第二步计算结果的最高位‘1’，然后去掉前面所有的‘0’就是最终结果

下面说明一下为什么这样计算是正确的

执行到第二步骤后，因为 

$$\\ x + z = x + b^n -y = x - y + b^n$$

假设 $y <= x$ 则 $x - y$ 最大是个 $n$ 位数，其为 

$$\\ x - y = e_1b^{n-1} + e_2b^{n-2} + … + e_n, (0<= e_1,e_2,…,e_n)$$

所以第二步后结果为

$$\\ x - y + b^n = 1b^n + e_1b^{n-1} + e_2b^{n-2} + … + e_n$$	

可见结果一定是个最高位是‘1’的 $n+1$ 位数，执行第三步实际相当于

$$\\ x - y + b^n -b^n = x -y $$

 对于 $x - y$不到 $n$ 位的情况，第三步相当于 $e_1…e_n$ 里有 $e_1..e_j (j <=n)$， 第三部的去掉‘0'的过程即是处理这种情况

##### 补码

从补数法我们可以知道，在二进制($b=2$)的情况下，减法也可以用加法实现，并且上文中的第三步正好和计算机里丢弃溢出位有相同的效果

由于 $a - b = a + (-b)$ ，所以在计算机里 $-b$ 可以用 $b$ 的 ‘补数’ 来替代，如果 $b$ > 0，则 $b$ 补数就可以表示它的负数，所以有符号数就可以用'**补码**'来表示了, 方法如下

* 如果是正数，和原码相同
* 如果是负数，是其正数每位取反后加1
* 0 只有一种表示，即每一位均是 0 

比如，在8位情况下 $+1$ 和 $-1$ 的表示为

$$[+1]_{反码} = 0000\ 0000\\ [-1]_{反码} = 1111\ 1110$$

一个  $n$ 位数表示的数的范围是 $-2^{n-1} <= x < 2^{n-1} -1$				

下面从数学角度说明一下用‘补码’进行计算的正确性， 假设  $a$ 和 $b$ 是 $n$ 位二进制下的两个数，计算 $a - b$ 

因为计算机下计算结果实际上是计算取模计算

$$\\ z \equiv (a - b)\mod 2^n$$

又因为

$$\\ 0 \equiv 2^n\mod  2^n$$

所以

$$\\ \begin{split}z \\ & \equiv (z + 0) \\ & \equiv (a - b + 2^n)\mod 2^n \\ & \equiv (a + \underbrace{2^n - b}_{b的补数})\mod 2^n \end{split}$$

即，最终结果 $z$ 与 $a$ 与 $b$ 的补数之和同余数，也就是 '$a$ 与 $b$ 的补数之和' 就是所求结果

补码和反码相比，都用最高位来表示符号，为1表示负数，0表示正数，但不同的是0在补码里只有一种表示，计算结果也不需要进行"端回进位"，所以如果用补码来表示有符号数来进行计算，计算单元在设计上比反码更简单，这也是它被广泛使用的原因



参考：

https://en.wikipedia.org/wiki/Radix

https://en.wikipedia.org/wiki/Method_of_complements#Binary_example

https://en.wikipedia.org/wiki/Signed_number_representations

http://www.neuraldump.com/2017/01/the-method-of-complements/








































​	
​	
